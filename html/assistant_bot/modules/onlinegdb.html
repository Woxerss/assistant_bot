<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>assistant_bot.modules.onlinegdb API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>assistant_bot.modules.onlinegdb</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import asyncio
from random import randint
from config import config
from aiogram import Bot, Dispatcher, types

from .utils.cache import Cache
from .utils.user import BotUser, Group
from .utils.db import PostgresDatabase
from .elements.keyboards import OnlineGdbInlineKeyboard, start_verification_keyboard

from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup
from aiogram.dispatcher.filters import Text

from .utils.onlinegdb import AutoOnlinegdb, Assignment

from filters.permissions import check_role

from .utils.markdown_escape import escape
from .utils.sheets.sheets import GradesSheet, Table

import re

class SelectAssignmentForm(StatesGroup):
    assignment_index = State()

class OnlineGdbModule():
    def __init__(self, dp: Dispatcher, bot: Bot):
        self.dp = dp
        self.bot = bot
        self.assignments_cache = {}
        self.action_cache = {}
        
        dp.register_callback_query_handler(self.on_onlinegdb_button_clicked, lambda c: c.data.startswith(&#34;groups_onlinegdb_&#34;), role=[&#39;teacher&#39;, &#39;admin&#39;])
        
        dp.register_callback_query_handler(self.on_review_one_clicked, lambda c: c.data.startswith(&#34;onlinegdb_review_one_&#34;), role=[&#39;teacher&#39;, &#39;admin&#39;])
        dp.register_callback_query_handler(self.on_grade_one_clicked, lambda c: c.data.startswith(&#34;onlinegdb_grade_one_&#34;), role=[&#39;teacher&#39;, &#39;admin&#39;])
        dp.register_callback_query_handler(self.on_review_all_clicked, lambda c: c.data.startswith(&#34;onlinegdb_review_all_&#34;), role=[&#39;teacher&#39;, &#39;admin&#39;])
        dp.register_callback_query_handler(self.on_grade_all_clicked, lambda c: c.data.startswith(&#34;onlinegdb_grade_all&#34;), role=[&#39;teacher&#39;, &#39;admin&#39;])
        
        dp.register_message_handler(self.on_assignment_index_received, state=SelectAssignmentForm.assignment_index)
        
    async def on_review_one_clicked(self, callback_query: types.CallbackQuery):
        print(&#39;on_review_one_clicked&#39;)
        group_index = int(callback_query.data.split(&#39;_&#39;)[-1])
        await self.bot.answer_callback_query(callback_query.id)
        self.action_cache[callback_query.from_user.id] = (group_index, &#39;review_one&#39;)
        await callback_query.message.answer(&#39;Введите номер задачи:&#39;)
        await SelectAssignmentForm.assignment_index.set()
        
    async def on_grade_one_clicked(self, callback_query: types.CallbackQuery):
        print(&#39;on_grade_one_clicked&#39;)
        group_index = int(callback_query.data.split(&#39;_&#39;)[-1])
        await self.bot.answer_callback_query(callback_query.id)
        self.action_cache[callback_query.from_user.id] = (group_index, &#39;grade_one&#39;)
        await callback_query.message.answer(&#39;Введите номер задачи:&#39;)
        await SelectAssignmentForm.assignment_index.set()
        
    async def on_review_all_clicked(self, callback_query: types.CallbackQuery):
        print(&#39;on_review_all_clicked&#39;)
        # Answer callback
        await self.bot.answer_callback_query(callback_query.id)
        
        group_index = int(callback_query.data.split(&#39;_&#39;)[-1])
        user: BotUser = Cache.get_user(callback_query.from_user.id)
        group = user.groups[group_index]
        
        agdb = AutoOnlinegdb(group.gdb)
        assignments_list = agdb.get_assignments()
        
        progress_message = await callback_query.message.answer(&#39;Начинаю проверку!&#39;)
        
        k = 0
        for i in range(len(assignments_list)):
            if (k &gt; 4):
                await progress_message.edit_text(f&#39;Проверено: {i}/{len(assignments_list)}&#39;)
                k = 0
            else:
                k += 1
            assignment: Assignment = assignments_list[i]
            if (assignment.pending_count &gt; 0):
                assignment.review()
        
        await progress_message.edit_text(f&#39;*Все задачи проверенны\\!*&#39;, parse_mode=&#34;MarkdownV2&#34;)
        await asyncio.sleep(5)
        await progress_message.delete()
        
    async def on_grade_all_clicked(self, callback_query: types.CallbackQuery):
        print(&#39;on_grade_all_clicked&#39;)
        # Answer callback
        await self.bot.answer_callback_query(callback_query.id)
        
        group_index = int(callback_query.data.split(&#39;_&#39;)[-1])
        user: BotUser = Cache.get_user(callback_query.from_user.id)
        group = user.groups[group_index]
        table = GradesSheet(group.sheets).get_onlinegdb_table()

        agdb = AutoOnlinegdb(group.gdb)
        assignments_list = agdb.get_assignments()
        
        progress_message = await callback_query.message.answer(&#39;Начинаю выставлять задачи!&#39;)
        
        k = 0
        for i in range(len(assignments_list)):
            assignment: Assignment = assignments_list[i]
            if (assignment.get_active_status()):
                print(f&#39;Пропустил: {assignment.name}&#39;)
                continue
            assignment.update_done()
            print(f&#39;Сейчас выставляю: {assignment.name}&#39;)
            if (k &gt; 4):
                await progress_message.edit_text(f&#39;Выставлено: {i}/{len(assignments_list)}&#39;)
                k = 0
            else:
                k += 1
            table.set_grade(assignment.id, assignment.done, assignment.name)
            await asyncio.sleep(1)
        await progress_message.edit_text(f&#39;*Все оценки выставлены\\!*&#39;, parse_mode=&#34;MarkdownV2&#34;)
        await asyncio.sleep(5)
        await progress_message.delete()
                 
    
    async def on_onlinegdb_button_clicked(self, callback_query: types.CallbackQuery):
        print(&#39;on_onlinegdb_button_clicked&#39;)
        # Answer callback
        await self.bot.answer_callback_query(callback_query.id)
        
        # Getting group
        user = Cache.get_user(callback_query.from_user.id)
        group_index = int(callback_query.data.split(&#39;_&#39;)[-1])
        group: Group = user.groups[group_index]
        
        # Get Assignments List
        agdb = AutoOnlinegdb(group.gdb)
        assignments_list = agdb.get_assignments()
        self.assignments_cache[user.id] = assignments_list

        # Build answer
        answer = f&#39;⚡*{group.name}*\n&#39;
        k = 0
        for assignment in assignments_list:
            assignment: Assignment
            answer += f&#39;*\\({k}\\)* {escape(assignment.name)} \\[{assignment.not_submitted_count}\\/{assignment.pending_count}\\/{assignment.done_count}\\]\n&#39;
            k += 1
        
        await callback_query.message.edit_text(answer, parse_mode=&#34;MarkdownV2&#34;, reply_markup=OnlineGdbInlineKeyboard(group_index))
    
    async def on_assignment_index_received(self, message: types.Message, state: FSMContext):
        if (re.match(r&#34;\d+&#34;, message.text)):
            index = int(message.text)
            user = Cache.get_user(message.from_id)
            action = self.action_cache[user.id]
            if (0 &lt;= index &lt;= len(self.assignments_cache[user.id])):
                if (action[1] == &#39;review_one&#39;):
                    await self.review_one(message, index)
                elif (action[1] == &#39;grade_one&#39;):
                    await self.grade_one(message, index)
                await state.finish()
                return
        await message.answer(&#39;Такой задачи нет. Попробуйте еще раз&#39;)
    
    async def send_onlinegdb_menu(self, message: types.Message, group):
        # Getting group
        user = Cache.get_user(message.from_id)
        group_index = int(group)
        group: Group = user.groups[group_index]
        
        # Get Assignments List
        agdb = AutoOnlinegdb(group.gdb)
        assignments_list = agdb.get_assignments()
        self.assignments_cache[user.id] = assignments_list

        # Build answer
        answer = f&#39;⚡*{group.name}*\n&#39;
        k = 0
        for assignment in assignments_list:
            assignment: Assignment
            answer += f&#39;*\\({k}\\)* {escape(assignment.name)} \\[{assignment.not_submitted_count}\\/{assignment.pending_count}\\/{assignment.done_count}\\]\n&#39;
            k += 1
        
        await message.answer(answer, parse_mode=&#34;MarkdownV2&#34;, reply_markup=OnlineGdbInlineKeyboard(group_index))
    
    async def review_one(self, message: types.Message, index):
        assignment: Assignment = self.assignments_cache[message.from_id][index]
        done_count = assignment.done_count
        done = assignment.done
        assignment.review()
        assignment.update_done()
        new_done = list(set(assignment.done) - set(done))
        answer = f&#39;Задача *{escape(assignment.name)}* проверена\\!\n&#39;
        answer += f&#39;Количество выполнивших: {assignment.done_count} \\(было: {done_count}\\)\n&#39;
        if (len(new_done)):
            answer += f&#39;Новые выполнившие\\:\n&#39;
            for child in new_done:
                answer += f&#39;{child}\n&#39;
        await message.answer(answer, parse_mode=&#34;MarkdownV2&#34;)
        await self.send_onlinegdb_menu(message, self.action_cache[message.from_id][0])
    
    async def grade_one(self, message, index):
        user: BotUser = Cache.get_user(message.from_id)
        action = self.action_cache[message.from_id]
        group: Group = user.groups[action[0]]
        
        table = GradesSheet(group.sheets).get_onlinegdb_table()
        
        assignment: Assignment = self.assignments_cache[user.id][index]
        assignment.update_done()
        table.set_grade(assignment.id, assignment.done, assignment.name)
        await message.answer(f&#39;Оценки за задачу {escape(assignment.name)} выставлены\\!&#39;, parse_mode=&#34;MarkdownV2&#34;)
        await self.send_onlinegdb_menu(message, self.action_cache[message.from_id][0])
        
    # Onlinegdb command
    async def onlinegdb_command(self, message: types.Message):
        # Only for admins and teachers
        if (not check_role(message, &#39;admin&#39;, &#39;teacher&#39;)):
            return
        
        # If user.groups empty
        user = Cache.get_user(message.from_id)
        if (len(user.groups) == 0):
            answer = &#34;*Вы еще не добавили ни одну группу\\!* \n&#34;
            answer += &#34;Выполните команду /group&#34;
            await message.answer(answer = answer, parse_mode=&#34;MarkdownV2&#34;)
        
def setup(dp: Dispatcher, bot):
    OnlineGdbModule(dp, bot)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="assistant_bot.modules.onlinegdb.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>dp: aiogram.dispatcher.dispatcher.Dispatcher, bot)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup(dp: Dispatcher, bot):
    OnlineGdbModule(dp, bot)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="assistant_bot.modules.onlinegdb.OnlineGdbModule"><code class="flex name class">
<span>class <span class="ident">OnlineGdbModule</span></span>
<span>(</span><span>dp: aiogram.dispatcher.dispatcher.Dispatcher, bot: aiogram.bot.bot.Bot)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OnlineGdbModule():
    def __init__(self, dp: Dispatcher, bot: Bot):
        self.dp = dp
        self.bot = bot
        self.assignments_cache = {}
        self.action_cache = {}
        
        dp.register_callback_query_handler(self.on_onlinegdb_button_clicked, lambda c: c.data.startswith(&#34;groups_onlinegdb_&#34;), role=[&#39;teacher&#39;, &#39;admin&#39;])
        
        dp.register_callback_query_handler(self.on_review_one_clicked, lambda c: c.data.startswith(&#34;onlinegdb_review_one_&#34;), role=[&#39;teacher&#39;, &#39;admin&#39;])
        dp.register_callback_query_handler(self.on_grade_one_clicked, lambda c: c.data.startswith(&#34;onlinegdb_grade_one_&#34;), role=[&#39;teacher&#39;, &#39;admin&#39;])
        dp.register_callback_query_handler(self.on_review_all_clicked, lambda c: c.data.startswith(&#34;onlinegdb_review_all_&#34;), role=[&#39;teacher&#39;, &#39;admin&#39;])
        dp.register_callback_query_handler(self.on_grade_all_clicked, lambda c: c.data.startswith(&#34;onlinegdb_grade_all&#34;), role=[&#39;teacher&#39;, &#39;admin&#39;])
        
        dp.register_message_handler(self.on_assignment_index_received, state=SelectAssignmentForm.assignment_index)
        
    async def on_review_one_clicked(self, callback_query: types.CallbackQuery):
        print(&#39;on_review_one_clicked&#39;)
        group_index = int(callback_query.data.split(&#39;_&#39;)[-1])
        await self.bot.answer_callback_query(callback_query.id)
        self.action_cache[callback_query.from_user.id] = (group_index, &#39;review_one&#39;)
        await callback_query.message.answer(&#39;Введите номер задачи:&#39;)
        await SelectAssignmentForm.assignment_index.set()
        
    async def on_grade_one_clicked(self, callback_query: types.CallbackQuery):
        print(&#39;on_grade_one_clicked&#39;)
        group_index = int(callback_query.data.split(&#39;_&#39;)[-1])
        await self.bot.answer_callback_query(callback_query.id)
        self.action_cache[callback_query.from_user.id] = (group_index, &#39;grade_one&#39;)
        await callback_query.message.answer(&#39;Введите номер задачи:&#39;)
        await SelectAssignmentForm.assignment_index.set()
        
    async def on_review_all_clicked(self, callback_query: types.CallbackQuery):
        print(&#39;on_review_all_clicked&#39;)
        # Answer callback
        await self.bot.answer_callback_query(callback_query.id)
        
        group_index = int(callback_query.data.split(&#39;_&#39;)[-1])
        user: BotUser = Cache.get_user(callback_query.from_user.id)
        group = user.groups[group_index]
        
        agdb = AutoOnlinegdb(group.gdb)
        assignments_list = agdb.get_assignments()
        
        progress_message = await callback_query.message.answer(&#39;Начинаю проверку!&#39;)
        
        k = 0
        for i in range(len(assignments_list)):
            if (k &gt; 4):
                await progress_message.edit_text(f&#39;Проверено: {i}/{len(assignments_list)}&#39;)
                k = 0
            else:
                k += 1
            assignment: Assignment = assignments_list[i]
            if (assignment.pending_count &gt; 0):
                assignment.review()
        
        await progress_message.edit_text(f&#39;*Все задачи проверенны\\!*&#39;, parse_mode=&#34;MarkdownV2&#34;)
        await asyncio.sleep(5)
        await progress_message.delete()
        
    async def on_grade_all_clicked(self, callback_query: types.CallbackQuery):
        print(&#39;on_grade_all_clicked&#39;)
        # Answer callback
        await self.bot.answer_callback_query(callback_query.id)
        
        group_index = int(callback_query.data.split(&#39;_&#39;)[-1])
        user: BotUser = Cache.get_user(callback_query.from_user.id)
        group = user.groups[group_index]
        table = GradesSheet(group.sheets).get_onlinegdb_table()

        agdb = AutoOnlinegdb(group.gdb)
        assignments_list = agdb.get_assignments()
        
        progress_message = await callback_query.message.answer(&#39;Начинаю выставлять задачи!&#39;)
        
        k = 0
        for i in range(len(assignments_list)):
            assignment: Assignment = assignments_list[i]
            if (assignment.get_active_status()):
                print(f&#39;Пропустил: {assignment.name}&#39;)
                continue
            assignment.update_done()
            print(f&#39;Сейчас выставляю: {assignment.name}&#39;)
            if (k &gt; 4):
                await progress_message.edit_text(f&#39;Выставлено: {i}/{len(assignments_list)}&#39;)
                k = 0
            else:
                k += 1
            table.set_grade(assignment.id, assignment.done, assignment.name)
            await asyncio.sleep(1)
        await progress_message.edit_text(f&#39;*Все оценки выставлены\\!*&#39;, parse_mode=&#34;MarkdownV2&#34;)
        await asyncio.sleep(5)
        await progress_message.delete()
                 
    
    async def on_onlinegdb_button_clicked(self, callback_query: types.CallbackQuery):
        print(&#39;on_onlinegdb_button_clicked&#39;)
        # Answer callback
        await self.bot.answer_callback_query(callback_query.id)
        
        # Getting group
        user = Cache.get_user(callback_query.from_user.id)
        group_index = int(callback_query.data.split(&#39;_&#39;)[-1])
        group: Group = user.groups[group_index]
        
        # Get Assignments List
        agdb = AutoOnlinegdb(group.gdb)
        assignments_list = agdb.get_assignments()
        self.assignments_cache[user.id] = assignments_list

        # Build answer
        answer = f&#39;⚡*{group.name}*\n&#39;
        k = 0
        for assignment in assignments_list:
            assignment: Assignment
            answer += f&#39;*\\({k}\\)* {escape(assignment.name)} \\[{assignment.not_submitted_count}\\/{assignment.pending_count}\\/{assignment.done_count}\\]\n&#39;
            k += 1
        
        await callback_query.message.edit_text(answer, parse_mode=&#34;MarkdownV2&#34;, reply_markup=OnlineGdbInlineKeyboard(group_index))
    
    async def on_assignment_index_received(self, message: types.Message, state: FSMContext):
        if (re.match(r&#34;\d+&#34;, message.text)):
            index = int(message.text)
            user = Cache.get_user(message.from_id)
            action = self.action_cache[user.id]
            if (0 &lt;= index &lt;= len(self.assignments_cache[user.id])):
                if (action[1] == &#39;review_one&#39;):
                    await self.review_one(message, index)
                elif (action[1] == &#39;grade_one&#39;):
                    await self.grade_one(message, index)
                await state.finish()
                return
        await message.answer(&#39;Такой задачи нет. Попробуйте еще раз&#39;)
    
    async def send_onlinegdb_menu(self, message: types.Message, group):
        # Getting group
        user = Cache.get_user(message.from_id)
        group_index = int(group)
        group: Group = user.groups[group_index]
        
        # Get Assignments List
        agdb = AutoOnlinegdb(group.gdb)
        assignments_list = agdb.get_assignments()
        self.assignments_cache[user.id] = assignments_list

        # Build answer
        answer = f&#39;⚡*{group.name}*\n&#39;
        k = 0
        for assignment in assignments_list:
            assignment: Assignment
            answer += f&#39;*\\({k}\\)* {escape(assignment.name)} \\[{assignment.not_submitted_count}\\/{assignment.pending_count}\\/{assignment.done_count}\\]\n&#39;
            k += 1
        
        await message.answer(answer, parse_mode=&#34;MarkdownV2&#34;, reply_markup=OnlineGdbInlineKeyboard(group_index))
    
    async def review_one(self, message: types.Message, index):
        assignment: Assignment = self.assignments_cache[message.from_id][index]
        done_count = assignment.done_count
        done = assignment.done
        assignment.review()
        assignment.update_done()
        new_done = list(set(assignment.done) - set(done))
        answer = f&#39;Задача *{escape(assignment.name)}* проверена\\!\n&#39;
        answer += f&#39;Количество выполнивших: {assignment.done_count} \\(было: {done_count}\\)\n&#39;
        if (len(new_done)):
            answer += f&#39;Новые выполнившие\\:\n&#39;
            for child in new_done:
                answer += f&#39;{child}\n&#39;
        await message.answer(answer, parse_mode=&#34;MarkdownV2&#34;)
        await self.send_onlinegdb_menu(message, self.action_cache[message.from_id][0])
    
    async def grade_one(self, message, index):
        user: BotUser = Cache.get_user(message.from_id)
        action = self.action_cache[message.from_id]
        group: Group = user.groups[action[0]]
        
        table = GradesSheet(group.sheets).get_onlinegdb_table()
        
        assignment: Assignment = self.assignments_cache[user.id][index]
        assignment.update_done()
        table.set_grade(assignment.id, assignment.done, assignment.name)
        await message.answer(f&#39;Оценки за задачу {escape(assignment.name)} выставлены\\!&#39;, parse_mode=&#34;MarkdownV2&#34;)
        await self.send_onlinegdb_menu(message, self.action_cache[message.from_id][0])
        
    # Onlinegdb command
    async def onlinegdb_command(self, message: types.Message):
        # Only for admins and teachers
        if (not check_role(message, &#39;admin&#39;, &#39;teacher&#39;)):
            return
        
        # If user.groups empty
        user = Cache.get_user(message.from_id)
        if (len(user.groups) == 0):
            answer = &#34;*Вы еще не добавили ни одну группу\\!* \n&#34;
            answer += &#34;Выполните команду /group&#34;
            await message.answer(answer = answer, parse_mode=&#34;MarkdownV2&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="assistant_bot.modules.onlinegdb.OnlineGdbModule.grade_one"><code class="name flex">
<span>async def <span class="ident">grade_one</span></span>(<span>self, message, index)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def grade_one(self, message, index):
    user: BotUser = Cache.get_user(message.from_id)
    action = self.action_cache[message.from_id]
    group: Group = user.groups[action[0]]
    
    table = GradesSheet(group.sheets).get_onlinegdb_table()
    
    assignment: Assignment = self.assignments_cache[user.id][index]
    assignment.update_done()
    table.set_grade(assignment.id, assignment.done, assignment.name)
    await message.answer(f&#39;Оценки за задачу {escape(assignment.name)} выставлены\\!&#39;, parse_mode=&#34;MarkdownV2&#34;)
    await self.send_onlinegdb_menu(message, self.action_cache[message.from_id][0])</code></pre>
</details>
</dd>
<dt id="assistant_bot.modules.onlinegdb.OnlineGdbModule.on_assignment_index_received"><code class="name flex">
<span>async def <span class="ident">on_assignment_index_received</span></span>(<span>self, message: aiogram.types.message.Message, state: aiogram.dispatcher.storage.FSMContext)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_assignment_index_received(self, message: types.Message, state: FSMContext):
    if (re.match(r&#34;\d+&#34;, message.text)):
        index = int(message.text)
        user = Cache.get_user(message.from_id)
        action = self.action_cache[user.id]
        if (0 &lt;= index &lt;= len(self.assignments_cache[user.id])):
            if (action[1] == &#39;review_one&#39;):
                await self.review_one(message, index)
            elif (action[1] == &#39;grade_one&#39;):
                await self.grade_one(message, index)
            await state.finish()
            return
    await message.answer(&#39;Такой задачи нет. Попробуйте еще раз&#39;)</code></pre>
</details>
</dd>
<dt id="assistant_bot.modules.onlinegdb.OnlineGdbModule.on_grade_all_clicked"><code class="name flex">
<span>async def <span class="ident">on_grade_all_clicked</span></span>(<span>self, callback_query: aiogram.types.callback_query.CallbackQuery)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_grade_all_clicked(self, callback_query: types.CallbackQuery):
    print(&#39;on_grade_all_clicked&#39;)
    # Answer callback
    await self.bot.answer_callback_query(callback_query.id)
    
    group_index = int(callback_query.data.split(&#39;_&#39;)[-1])
    user: BotUser = Cache.get_user(callback_query.from_user.id)
    group = user.groups[group_index]
    table = GradesSheet(group.sheets).get_onlinegdb_table()

    agdb = AutoOnlinegdb(group.gdb)
    assignments_list = agdb.get_assignments()
    
    progress_message = await callback_query.message.answer(&#39;Начинаю выставлять задачи!&#39;)
    
    k = 0
    for i in range(len(assignments_list)):
        assignment: Assignment = assignments_list[i]
        if (assignment.get_active_status()):
            print(f&#39;Пропустил: {assignment.name}&#39;)
            continue
        assignment.update_done()
        print(f&#39;Сейчас выставляю: {assignment.name}&#39;)
        if (k &gt; 4):
            await progress_message.edit_text(f&#39;Выставлено: {i}/{len(assignments_list)}&#39;)
            k = 0
        else:
            k += 1
        table.set_grade(assignment.id, assignment.done, assignment.name)
        await asyncio.sleep(1)
    await progress_message.edit_text(f&#39;*Все оценки выставлены\\!*&#39;, parse_mode=&#34;MarkdownV2&#34;)
    await asyncio.sleep(5)
    await progress_message.delete()</code></pre>
</details>
</dd>
<dt id="assistant_bot.modules.onlinegdb.OnlineGdbModule.on_grade_one_clicked"><code class="name flex">
<span>async def <span class="ident">on_grade_one_clicked</span></span>(<span>self, callback_query: aiogram.types.callback_query.CallbackQuery)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_grade_one_clicked(self, callback_query: types.CallbackQuery):
    print(&#39;on_grade_one_clicked&#39;)
    group_index = int(callback_query.data.split(&#39;_&#39;)[-1])
    await self.bot.answer_callback_query(callback_query.id)
    self.action_cache[callback_query.from_user.id] = (group_index, &#39;grade_one&#39;)
    await callback_query.message.answer(&#39;Введите номер задачи:&#39;)
    await SelectAssignmentForm.assignment_index.set()</code></pre>
</details>
</dd>
<dt id="assistant_bot.modules.onlinegdb.OnlineGdbModule.on_onlinegdb_button_clicked"><code class="name flex">
<span>async def <span class="ident">on_onlinegdb_button_clicked</span></span>(<span>self, callback_query: aiogram.types.callback_query.CallbackQuery)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_onlinegdb_button_clicked(self, callback_query: types.CallbackQuery):
    print(&#39;on_onlinegdb_button_clicked&#39;)
    # Answer callback
    await self.bot.answer_callback_query(callback_query.id)
    
    # Getting group
    user = Cache.get_user(callback_query.from_user.id)
    group_index = int(callback_query.data.split(&#39;_&#39;)[-1])
    group: Group = user.groups[group_index]
    
    # Get Assignments List
    agdb = AutoOnlinegdb(group.gdb)
    assignments_list = agdb.get_assignments()
    self.assignments_cache[user.id] = assignments_list

    # Build answer
    answer = f&#39;⚡*{group.name}*\n&#39;
    k = 0
    for assignment in assignments_list:
        assignment: Assignment
        answer += f&#39;*\\({k}\\)* {escape(assignment.name)} \\[{assignment.not_submitted_count}\\/{assignment.pending_count}\\/{assignment.done_count}\\]\n&#39;
        k += 1
    
    await callback_query.message.edit_text(answer, parse_mode=&#34;MarkdownV2&#34;, reply_markup=OnlineGdbInlineKeyboard(group_index))</code></pre>
</details>
</dd>
<dt id="assistant_bot.modules.onlinegdb.OnlineGdbModule.on_review_all_clicked"><code class="name flex">
<span>async def <span class="ident">on_review_all_clicked</span></span>(<span>self, callback_query: aiogram.types.callback_query.CallbackQuery)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_review_all_clicked(self, callback_query: types.CallbackQuery):
    print(&#39;on_review_all_clicked&#39;)
    # Answer callback
    await self.bot.answer_callback_query(callback_query.id)
    
    group_index = int(callback_query.data.split(&#39;_&#39;)[-1])
    user: BotUser = Cache.get_user(callback_query.from_user.id)
    group = user.groups[group_index]
    
    agdb = AutoOnlinegdb(group.gdb)
    assignments_list = agdb.get_assignments()
    
    progress_message = await callback_query.message.answer(&#39;Начинаю проверку!&#39;)
    
    k = 0
    for i in range(len(assignments_list)):
        if (k &gt; 4):
            await progress_message.edit_text(f&#39;Проверено: {i}/{len(assignments_list)}&#39;)
            k = 0
        else:
            k += 1
        assignment: Assignment = assignments_list[i]
        if (assignment.pending_count &gt; 0):
            assignment.review()
    
    await progress_message.edit_text(f&#39;*Все задачи проверенны\\!*&#39;, parse_mode=&#34;MarkdownV2&#34;)
    await asyncio.sleep(5)
    await progress_message.delete()</code></pre>
</details>
</dd>
<dt id="assistant_bot.modules.onlinegdb.OnlineGdbModule.on_review_one_clicked"><code class="name flex">
<span>async def <span class="ident">on_review_one_clicked</span></span>(<span>self, callback_query: aiogram.types.callback_query.CallbackQuery)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_review_one_clicked(self, callback_query: types.CallbackQuery):
    print(&#39;on_review_one_clicked&#39;)
    group_index = int(callback_query.data.split(&#39;_&#39;)[-1])
    await self.bot.answer_callback_query(callback_query.id)
    self.action_cache[callback_query.from_user.id] = (group_index, &#39;review_one&#39;)
    await callback_query.message.answer(&#39;Введите номер задачи:&#39;)
    await SelectAssignmentForm.assignment_index.set()</code></pre>
</details>
</dd>
<dt id="assistant_bot.modules.onlinegdb.OnlineGdbModule.onlinegdb_command"><code class="name flex">
<span>async def <span class="ident">onlinegdb_command</span></span>(<span>self, message: aiogram.types.message.Message)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def onlinegdb_command(self, message: types.Message):
    # Only for admins and teachers
    if (not check_role(message, &#39;admin&#39;, &#39;teacher&#39;)):
        return
    
    # If user.groups empty
    user = Cache.get_user(message.from_id)
    if (len(user.groups) == 0):
        answer = &#34;*Вы еще не добавили ни одну группу\\!* \n&#34;
        answer += &#34;Выполните команду /group&#34;
        await message.answer(answer = answer, parse_mode=&#34;MarkdownV2&#34;)</code></pre>
</details>
</dd>
<dt id="assistant_bot.modules.onlinegdb.OnlineGdbModule.review_one"><code class="name flex">
<span>async def <span class="ident">review_one</span></span>(<span>self, message: aiogram.types.message.Message, index)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def review_one(self, message: types.Message, index):
    assignment: Assignment = self.assignments_cache[message.from_id][index]
    done_count = assignment.done_count
    done = assignment.done
    assignment.review()
    assignment.update_done()
    new_done = list(set(assignment.done) - set(done))
    answer = f&#39;Задача *{escape(assignment.name)}* проверена\\!\n&#39;
    answer += f&#39;Количество выполнивших: {assignment.done_count} \\(было: {done_count}\\)\n&#39;
    if (len(new_done)):
        answer += f&#39;Новые выполнившие\\:\n&#39;
        for child in new_done:
            answer += f&#39;{child}\n&#39;
    await message.answer(answer, parse_mode=&#34;MarkdownV2&#34;)
    await self.send_onlinegdb_menu(message, self.action_cache[message.from_id][0])</code></pre>
</details>
</dd>
<dt id="assistant_bot.modules.onlinegdb.OnlineGdbModule.send_onlinegdb_menu"><code class="name flex">
<span>async def <span class="ident">send_onlinegdb_menu</span></span>(<span>self, message: aiogram.types.message.Message, group)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_onlinegdb_menu(self, message: types.Message, group):
    # Getting group
    user = Cache.get_user(message.from_id)
    group_index = int(group)
    group: Group = user.groups[group_index]
    
    # Get Assignments List
    agdb = AutoOnlinegdb(group.gdb)
    assignments_list = agdb.get_assignments()
    self.assignments_cache[user.id] = assignments_list

    # Build answer
    answer = f&#39;⚡*{group.name}*\n&#39;
    k = 0
    for assignment in assignments_list:
        assignment: Assignment
        answer += f&#39;*\\({k}\\)* {escape(assignment.name)} \\[{assignment.not_submitted_count}\\/{assignment.pending_count}\\/{assignment.done_count}\\]\n&#39;
        k += 1
    
    await message.answer(answer, parse_mode=&#34;MarkdownV2&#34;, reply_markup=OnlineGdbInlineKeyboard(group_index))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="assistant_bot.modules.onlinegdb.SelectAssignmentForm"><code class="flex name class">
<span>class <span class="ident">SelectAssignmentForm</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SelectAssignmentForm(StatesGroup):
    assignment_index = State()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>aiogram.dispatcher.filters.state.StatesGroup</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="assistant_bot.modules.onlinegdb.SelectAssignmentForm.assignment_index"><code class="name">var <span class="ident">assignment_index</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="assistant_bot.modules" href="index.html">assistant_bot.modules</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="assistant_bot.modules.onlinegdb.setup" href="#assistant_bot.modules.onlinegdb.setup">setup</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="assistant_bot.modules.onlinegdb.OnlineGdbModule" href="#assistant_bot.modules.onlinegdb.OnlineGdbModule">OnlineGdbModule</a></code></h4>
<ul class="">
<li><code><a title="assistant_bot.modules.onlinegdb.OnlineGdbModule.grade_one" href="#assistant_bot.modules.onlinegdb.OnlineGdbModule.grade_one">grade_one</a></code></li>
<li><code><a title="assistant_bot.modules.onlinegdb.OnlineGdbModule.on_assignment_index_received" href="#assistant_bot.modules.onlinegdb.OnlineGdbModule.on_assignment_index_received">on_assignment_index_received</a></code></li>
<li><code><a title="assistant_bot.modules.onlinegdb.OnlineGdbModule.on_grade_all_clicked" href="#assistant_bot.modules.onlinegdb.OnlineGdbModule.on_grade_all_clicked">on_grade_all_clicked</a></code></li>
<li><code><a title="assistant_bot.modules.onlinegdb.OnlineGdbModule.on_grade_one_clicked" href="#assistant_bot.modules.onlinegdb.OnlineGdbModule.on_grade_one_clicked">on_grade_one_clicked</a></code></li>
<li><code><a title="assistant_bot.modules.onlinegdb.OnlineGdbModule.on_onlinegdb_button_clicked" href="#assistant_bot.modules.onlinegdb.OnlineGdbModule.on_onlinegdb_button_clicked">on_onlinegdb_button_clicked</a></code></li>
<li><code><a title="assistant_bot.modules.onlinegdb.OnlineGdbModule.on_review_all_clicked" href="#assistant_bot.modules.onlinegdb.OnlineGdbModule.on_review_all_clicked">on_review_all_clicked</a></code></li>
<li><code><a title="assistant_bot.modules.onlinegdb.OnlineGdbModule.on_review_one_clicked" href="#assistant_bot.modules.onlinegdb.OnlineGdbModule.on_review_one_clicked">on_review_one_clicked</a></code></li>
<li><code><a title="assistant_bot.modules.onlinegdb.OnlineGdbModule.onlinegdb_command" href="#assistant_bot.modules.onlinegdb.OnlineGdbModule.onlinegdb_command">onlinegdb_command</a></code></li>
<li><code><a title="assistant_bot.modules.onlinegdb.OnlineGdbModule.review_one" href="#assistant_bot.modules.onlinegdb.OnlineGdbModule.review_one">review_one</a></code></li>
<li><code><a title="assistant_bot.modules.onlinegdb.OnlineGdbModule.send_onlinegdb_menu" href="#assistant_bot.modules.onlinegdb.OnlineGdbModule.send_onlinegdb_menu">send_onlinegdb_menu</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="assistant_bot.modules.onlinegdb.SelectAssignmentForm" href="#assistant_bot.modules.onlinegdb.SelectAssignmentForm">SelectAssignmentForm</a></code></h4>
<ul class="">
<li><code><a title="assistant_bot.modules.onlinegdb.SelectAssignmentForm.assignment_index" href="#assistant_bot.modules.onlinegdb.SelectAssignmentForm.assignment_index">assignment_index</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>